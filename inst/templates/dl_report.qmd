---
title: "Harvest Information Program Download Cycle Report"
date: today
format: 
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true
    embed-resources: true
    anchor-sections: false
params:
  comp_path:
    value: x
  final_path:
    value: x
  future_path:
    value: x
  past_path:
    value: x
  dl:
    value: x
  year:
    value: x
---


```{r libs}
#| include: false

`%within%` <- lubridate::`%within%`
```


```{r import}
#| include: false

dl_data <- 
  read_hip(params$comp_path) |> 
  dplyr::mutate(dl_cycle = params$dl)

# Standardize birth date format
fixed_dates_data <-
  dl_data |> 
  dplyr::mutate(
    birth_date2 =
      ifelse(
        stringr::str_detect(birth_date, "^[0-9]{1}\\/"),
        paste0("0", birth_date),
        birth_date),
    birth_date3 =
      ifelse(
        stringr::str_length(birth_date2) == 9,
        paste0(
          stringr::str_sub(birth_date2, 1, 3),
          "0",
          stringr::str_sub(birth_date2, 4, 9)),
        birth_date2)) |> 
  dplyr::select(-c("birth_date", "birth_date2")) |>
  dplyr::rename(birth_date = birth_date3) |>
  dplyr::relocate(birth_date, .before = "issue_date") 

# Snoop for line shift errors
error_keys <- 
  fixed_dates_data |> 
  dplyr::filter(
    !stringr::str_detect(
      birth_date, "^[0-9]{2}\\/[0-9]{2}\\/[0-9]{4}$")) |> 
  dplyr::relocate(record_key, .before = "title") |> 
  dplyr::relocate(source_file, .before = "record_key") |>
  dplyr::select(record_key) |> 
  dplyr::pull()

# Correct frame shifts for x number of records
if(length(error_keys) > 0){
  unshifted <-
    purrr::map_dfr(
      1:length(error_keys),
      ~shiftFix(fixed_dates_data, error_keys[.x], "state", "email", 1)
    ) |> 
    # Delete the 0s from end of zip
    dplyr::mutate(zip = stringr::str_remove(zip, "0$")) |>
    dplyr::mutate(
      birth_date =
        ifelse(
          stringr::str_detect(birth_date, "^[0-9]{1}\\/"),
          paste0("0", birth_date),
          birth_date))
}else{
  unshifted <- NULL
}

rm(error_keys)

unshifted_data <-
  fixed_dates_data |>
  dplyr::filter(!record_key %in% unshifted$record_key) |>
  dplyr::bind_rows(unshifted) 

rm(fixed_dates_data)
rm(unshifted)

cleaned_data <- clean(unshifted_data)

rm(unshifted_data)

current_data <- issueCheck(cleaned_data, params$year, write = F)

fixed_data <- fixDuplicates(current_data)

proofed_data <- proof(fixed_data, year = params$year)

# Read in the completed download data (for better/more accurate figures and tables)
final_data <-
  purrr::map_df(
    1:length(list.files(params$final_path)),
    ~data.table::fread(
      paste0(params$final_path, list.files(params$final_path)[.x]),
      colClasses = rep("character", 38),
      na.strings = "") |> 
      dplyr::select(1:28) |> 
      dplyr::rename(
        zip = postal_code,
        ducks_bag = Q_ducks,
        geese_bag = Q_geese,
        dove_bag = Q_doves,
        woodcock_bag = Q_woodcock,
        coots_snipe = Q_coot_snipe,
        rails_gallinules = Q_rail_gallinule,
        cranes = Q_cranes,
        band_tailed_pigeon = Q_bt_pigeons,
        brant = Q_brant,
        seaducks = Q_seaducks,
        dl_cycle = dl)) |> 
  proof(year = params$year) |> 
  dplyr::mutate(
    # Add the download date as a column
    dl_date =
      stringr::str_extract(source_file, "(?<=[A-Z]{2})[0-9]{8}(?=\\.txt)"))

can <- c("AB", "BC", "MB", "NB", "NL", "NT", "NS", 
         "NU", "ON", "PE", "QC", "SK", "YT")

# Summarize number of records from Canada
canada_records <-
  final_data |> 
  dplyr::select(state) |> 
  dplyr::filter(state %in% can) |> 
  nrow()

# Summarize number of bad zip codes
zip_check <-
  final_data |> 
  dplyr::filter(!state %in% can) |> 
  dplyr::mutate(zipPrefix = stringr::str_extract(zip, "^[0-9]{3}")) |>
  dplyr::left_join(
    migbirdHIP:::zip_code_ref |>
      dplyr::select(zipPrefix, zipState = state),
    by = "zipPrefix") |>
  dplyr::filter(state != zipState) |> 
  nrow()

```

# Introduction

This is a report of download cycle `r proofed_data |> dplyr::select(dl_cycle) |> dplyr::distinct() |> dplyr::pull()`. This cycle, `r sumLines(params$comp_path)` lines of data (`r nrow(final_data)` unique records) were submitted in `r length(list.files(params$comp_path, recursive = F, pattern = "*\\.txt$", ignore.case = TRUE))` files from `r proofed_data |> dplyr::select(dl_state) |> dplyr::distinct() |> nrow()` states. A total of `r canada_records` records were received from Canada, and `r zip_check` records did not have a zip code that matched the address state.

```{r data_sweep}
#| include: false

rm(canada_records)
rm(zip_check)
```


Below is a table summarizing the total of number of records per download state.

```{r sum_per_state}
#| message: false
#| echo: false

DT::datatable(
  final_data |> 
    dplyr::select(dl_state) |> 
    dplyr::group_by(dl_state) |> 
    dplyr::summarize(sum = dplyr::n()) |> 
    dplyr::ungroup())

```

# Data Checking

## Registration year checking

### Summary of registration_yr

```{r reg_yr_check}
#| echo: false

reg_yr_summary <-
  final_data |> 
    dplyr::select(registration_yr, dl_state) |> 
    # Filter out records from this year since we know they are good
    dplyr::filter(registration_yr != as.character(params$year)) |> 
    dplyr::group_by(registration_yr, dl_state) |> 
    dplyr::summarize(n = dplyr::n()) |> 
    dplyr::ungroup()

if(nrow(reg_yr_summary) > 0){
  DT::datatable(reg_yr_summary)
}else{
  message(paste0("All registration years = ", as.character(params$year), "."))
}

rm(reg_yr_summary)
```

### Records changed for this season and copied for next season

Records below had their registration_yr edited to be compatible for this HIP season and were also copied and exported for next HIP season.

```{r reg_yr_check2}
#| echo: false

twoseasonstates <-
  migbirdHIP:::licenses_ref |>
  dplyr::filter(category == "2 season") |>
  dplyr::select(state) |>
  dplyr::pull()

issue_assignments <-
  cleaned_data |>
  dplyr::left_join(
    migbirdHIP:::licenses_ref |>
      dplyr::rename(dl_state = state),
    by = "dl_state") |>
  # Filter out bad issue_date values
  dplyr::filter(issue_date != "00/00/0000") |>
  dplyr::mutate(
    # Calculate registration_yr for all one-season states
    # (does not include MS)
    issue_eval =
      ifelse(
        !dl_state %in% c(twoseasonstates, "MS"),
        dplyr::case_when(
          lubridate::mdy(issue_date) %within%
            lubridate::interval(issue_start, last_day_migbird_hunting) ~ "current",
          lubridate::mdy(issue_date) < issue_start ~ "past",
          lubridate::mdy(issue_date) > last_day_migbird_hunting ~ "future",
          TRUE ~ "bad issue dates"),
        "two season state"),
    reg_yr_eval =
      dplyr::case_when(
        # For records from two-season states with a future registration year
        # and issue_date before the last day of hunting, copy them for next
        # year (and count them for this year)
        dl_state %in% twoseasonstates &
          registration_yr == as.character(params$year + 1) &
          lubridate::mdy(issue_date) %within%
            lubridate::interval(issue_start, last_day_migbird_hunting) ~ "copy",
        # For records from two-season states with a current registration
        # year and issue date after the last day of hunting, postpone
        # sampling them until next year
        dl_state %in% twoseasonstates &
          registration_yr == as.character(params$year) &
          lubridate::mdy(issue_date) > last_day_migbird_hunting ~ "postpone",
        # For records from Mississippi, if the issue_date is within
        # Mississippi's hunting season, copy them for next year (and count
        # them for this year)
        dl_state == "MS" &
          lubridate::mdy(issue_date) %within% 
            lubridate::interval(
              migbirdHIP:::MS_firstday, migbirdHIP:::MS_lastday) ~ "copy",
        # Postpone all other future registration_yr values, for all states
        registration_yr == as.character(params$year + 1) ~ "postpone",
        # Check for yr-1 registration_yr values for all states
        registration_yr == as.character(params$year - 1) ~ "past",
        TRUE ~ "nochange"),
    # Assign destination of each record to decision
    decision =
      dplyr::case_when(
        issue_eval == "current" & reg_yr_eval == "nochange" ~ "nochange",
        issue_eval == "current" & reg_yr_eval == "past" ~ "bad",
        issue_eval == "current" & reg_yr_eval == "copy" ~ "copy",
        issue_eval == "current" & reg_yr_eval == "postpone" ~ "postpone",
        issue_eval == "past" & reg_yr_eval == "nochange" ~ "bad",
        issue_eval == "past" & reg_yr_eval == "past" ~ "past",
        issue_eval == "past" & reg_yr_eval == "copy" ~ "bad",
        issue_eval == "past" & reg_yr_eval == "postpone" ~ "bad",
        issue_eval == "future" & reg_yr_eval == "nochange" ~ "bad",
        issue_eval == "future" & reg_yr_eval == "past" ~ "bad",
        issue_eval == "future" & reg_yr_eval == "copy" ~ "copy",
        issue_eval == "future" & reg_yr_eval == "postpone" ~ "postpone",
        issue_eval == "two season state" & reg_yr_eval == "nochange" ~
          "nochange",
        issue_eval == "two season state" & reg_yr_eval == "past" ~ "past",
        issue_eval == "two season state" & reg_yr_eval == "copy" ~ "copy",
        issue_eval == "two season state" & reg_yr_eval == "postpone" ~
          "postpone",
        TRUE ~ NA_character_)
  ) |>
  dplyr::select(-c("hunting_season", "issue_start", "issue_end",
            "last_day_migbird_hunting", "category"))

if(nrow(issue_assignments |> dplyr::filter(decision == "copy")) > 0){
  
  current_records <-
    issue_assignments |>
    dplyr::filter(decision != "postpone") |>
    dplyr::mutate(
      registration_yr =
        ifelse(
          decision == "copy",
          as.character(as.numeric(registration_yr)-1),
          registration_yr)) |>
    dplyr::filter(decision == "copy") |> 
    dplyr::select(-decision) 
  
  current_summary <- 
    current_records |> 
    dplyr::group_by(dl_state, registration_yr) |> 
    dplyr::summarize(n = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(n))
  
  DT::datatable(current_summary)
}else{
  message("No records to change/copy.")
}

```

### Future records

Records below have an issue_date and registration_yr indicating they should be set aside for next year.

```{r reg_yr_check3}
#| echo: false

if(!stringr::str_detect(params$future_path, "\\/$")){
  future_path <- paste0(params$future_path, "/")
}else{
  future_path <- params$future_path
}

future_file <- paste0("DL", params$dl, "_future_data.csv")

if(future_file %in% list.files(future_path)){
  future_data <-
    readr::read_csv(paste0(future_path, future_file), show_col_types = F)
  
  suppressMessages(
    future_summary <- 
      future_data |> 
      dplyr::group_by(dl_state, registration_yr) |> 
      dplyr::summarize(n = dplyr::n()) |> 
      dplyr::ungroup() |> 
      dplyr::arrange(dplyr::desc(n)))
  
  DT::datatable(future_summary)
  
  rm(future_data)
  rm(future_summary)
}else{
  message("No records to postpone.")
}

rm(future_path)
rm(future_file)

```

### Past records

Records below have an issue_date and registration_yr indicating they qualify for a previous HIP season; these records were set aside and are not be elibigle to be sampled.

```{r reg_yr_check4}
#| echo: false

if(!stringr::str_detect(params$past_path, "\\/$")){
  past_path <- paste0(params$past_path, "/")
}else{
  past_path <- params$past_path
}

past_file <- paste0("DL", params$dl, "_past_data.csv")

if(past_file %in% list.files(past_path)){
  past_data <-
    readr::read_csv(paste0(past_path, past_file), show_col_types = F)
  
  suppressMessages(
    past_summary <- 
      past_data |> 
      dplyr::group_by(dl_state, registration_yr) |> 
      dplyr::summarize(n = dplyr::n()) |> 
      dplyr::ungroup() |> 
      dplyr::arrange(dplyr::desc(n)))
  
  DT::datatable(past_summary)
  
  rm(past_data)
  rm(past_summary)
}else{
  message("No past records.")
}

rm(past_path)
rm(past_file)

```

### Irreconcilable records

Records below did not have an issue_date and registration_yr that were in agreement.

```{r reg_yr_check5}
#| echo: false
#| fig.align: center

if(nrow(issue_assignments |> filter(decision == "bad")) > 0){
  rectangles <-
    tibble::tibble(
      season = c(paste(params$year-1, params$year, sep = "-"),
                 paste(params$year, params$year+1, sep = "-"),
                 paste(params$year+1, params$year+2, sep = "-")),
      values = c("#F0E442", "#56B4E9", "#0072B2"),
      xmin = c(as.Date(paste(params$year-1, "09-01", sep = "-")),
               as.Date(paste(params$year, "09-01", sep = "-")),
               as.Date(paste(params$year+1, "09-01", sep = "-"))),
      xmax = c(as.Date(paste(params$year, "03-11", sep = "-")),
               as.Date(paste(params$year+1, "03-11", sep = "-")),
               as.Date(paste(params$year+2, "03-11", sep = "-"))),
      ymin = -Inf,
      ymax = Inf)
  
  issue_assignments |>
    dplyr::filter(decision == "bad") |>
    dplyr::select(dl_state, source_file, issue_date, registration_yr, decision) |>
    dplyr::left_join(
      migbirdHIP:::licenses_ref |>
      dplyr::rename(dl_state = state),
      by = "dl_state") |>
    dplyr::distinct() |>
    ggplot2::ggplot() +
    ggplot2::geom_rect(
      data = rectangles,
      ggplot2::aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax,
          fill = season),
      alpha = 0.3, 
      inherit.aes = F) +
    ggplot2::geom_boxplot(
      ggplot2::aes(x = lubridate::mdy(issue_date), y = dl_state, color = registration_yr),
      fill = "#FFFFFF", 
      width = 0, 
      size = 3, 
      position = "identity") +
    ggplot2::geom_point(
      ggplot2::aes(
        x = last_day_migbird_hunting, 
        y = dl_state, 
        shape = "Last day of hunting")) +
    ggplot2::geom_point(
      ggplot2::aes(x = issue_start, y = dl_state, shape = "Issue start")) +
    ggplot2::geom_point(
      ggplot2::aes(x = issue_end, y = dl_state, shape = "Issue end")) +
    ggplot2::labs(x = "Date", y = "State",
         title = "Bad issue_date/registration_yr combinations") +
    ggplot2::scale_fill_manual(
      "Seasons",
      labels = c(paste(params$year-1, params$year, sep = "-"),
                       paste(params$year, params$year+1, sep = "-"),
                       paste(params$year+1, params$year+2, sep = "-")),
      values = c("#F0E442", "#56B4E9", "#0072B2")) +
    ggplot2::scale_shape_manual(
      name = "", values = c(4, 1, 2)) +
    ggplot2::scale_x_date(
      breaks = c(rectangles$xmin[1], rectangles$xmax[1],
                 rectangles$xmin[2], rectangles$xmax[2],
                 rectangles$xmin[3], rectangles$xmax[3])) +
    ggplot2::theme_classic() +
    ggplot2::theme(
      axis.text = ggplot2::element_text(size = 11),
      axis.title = ggplot2::element_text(size = 14),
      panel.background = ggplot2::element_rect(color = "white"),
      panel.grid.major.y = 
        ggplot2::element_line(color = "#666666", linetype = "dotted"))
}else{
  message("No bad data to plot.")
}
```

```{r reg_yr_check6}
#| echo: false

if(nrow(issue_assignments |> dplyr::filter(decision == "bad")) > 0){
  DT::datatable(
    issue_assignments |>
      dplyr::filter(decision == "bad") |>
      dplyr::select(dl_state, source_file, issue_date, registration_yr) |>
      dplyr::left_join(
        migbirdHIP:::licenses_ref |>
          dplyr::select(
            -c("hunting_season", "last_day_migbird_hunting", "category")) |> 
          dplyr::rename(dl_state = state),
        by = "dl_state") |>
      dplyr::distinct() |> 
      dplyr::group_by(
        dl_state, source_file, registration_yr, issue_start, issue_end) |> 
      dplyr::summarize(
        min_issue_date = min(lubridate::mdy(issue_date)),
        max_issue_date = max(lubridate::mdy(issue_date))) |> 
      dplyr::ungroup() |> 
      dplyr::relocate(
        min_issue_date:max_issue_date, .before = "registration_yr")
    )
}

rm(issue_assignments)
rm(twoseasonstates)
```


## HuntY response checking

```{r hunty_check}
#| echo: false

suppressMessages(
  huntcheck <-
    final_data |> 
    dplyr::select(hunt_mig_birds, dl_state) |> 
    dplyr::group_by(dl_state) |> 
    dplyr::mutate(total_state_n = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::filter(hunt_mig_birds != 2) |> 
    dplyr::group_by(hunt_mig_birds, dl_state) |> 
    dplyr::summarize(
      n = dplyr::n(),
      prop = round(dplyr::n()/total_state_n, 2)) |> 
    dplyr::ungroup() |> 
    dplyr::distinct() |> 
    dplyr::arrange(dplyr::desc(prop))
)

if(nrow(huntcheck) > 0){
  DT::datatable(huntcheck)
  }else{
  message("All HuntY = 2.")
}

rm(huntcheck)
```

## PII checking

The following records are missing first name, last name, date of birth, address AND email, OR city AND zip AND email. They are not included in the final output table.

```{r record_check}
#| echo: false
#| fig.align: center

record_check <- 
  dl_data |>
  # Filter out records if firstname, lastname, state, birth date, OR address AND
  # email, OR city, zip AND email are missing -- records discarded because these
  # are needed to identify individuals Discard additional records if they are
  # missing elements of an address AND email
  dplyr::filter(
    dplyr::if_any(
      c("firstname", "lastname", "state", "birth_date"), ~is.na(.x))|
      dplyr::if_all(c("address", "email"), ~is.na(.x))|
      dplyr::if_all(c("city", "zip", "email"), ~is.na(.x)))
    
if(nrow(record_check) > 0){
  missing_plot <-
    record_check |>
    dplyr::select(
      firstname, lastname, birth_date, state, address, city, zip, email) |>
    # Add an ID per row
    dplyr::mutate(hunter_id = row_number()) |>
    # Pivot the field names to long format
    tidyr::pivot_longer(firstname:email, names_to = "field") |>
    # Only keep hunters' fields with NA values
    dplyr::filter(is.na(value)) |>
    # Set NA to 1 for plotting
    dplyr::mutate(value = 1) |>
    # Make a heat map
    ggplot2::ggplot(
      ggplot2::aes(x = field, y = as.factor(hunter_id), fill = value)) +
    ggplot2::geom_tile() +
    ggplot2::labs(y = "Hunter ID", x = "Data Field") +
    ggplot2::theme_classic() +
    ggplot2::theme(
      legend.position = "none",
      axis.text.y = ggplot2::element_blank(),
      axis.ticks.y = ggplot2::element_blank())

  print(missing_plot)}else{
  message("No records detected with missing PII.")
}
```

There are `r nrow(record_check)` total records with missing PII. Below is a summary of the number of records missing from each HIP file.

```{r pii_by_file}
#| echo: false

pii_summary <- 
  record_check |> 
  dplyr::group_by(source_file) |> 
  dplyr::summarize(n = dplyr::n()) |> 
  dplyr::ungroup() |> 
  dplyr::left_join(
    dl_data |> 
      dplyr::select(source_file) |> 
      dplyr::group_by(source_file) |> 
      dplyr::mutate(total_rows = dplyr::n()) |> 
      dplyr::ungroup(),
    by = "source_file") |> 
  dplyr::mutate(prop = round(n/total_rows, digits = 2)) |> 
  dplyr::select(-total_rows) |> 
  dplyr::distinct() |> 
  dplyr::arrange(dplyr::desc(prop)) 

DT::datatable(pii_summary)
rm(pii_summary)
rm(dl_data)
```

## Missing email checking

Emails missing or detected to be incorrect are shown below. Values are sourced from the corrected data.

```{r missingemail}
#| echo: false
#| fig.align: center
#| warning: false

final_data |> 
  dplyr::select(dl_state, email, errors) |> 
  dplyr::mutate(
    errors = ifelse(is.na(errors), "na", errors),
    Category = 
      dplyr::case_when(
        !is.na(email) & !stringr::str_detect(errors, "email") ~ "Good",
        !is.na(email) & stringr::str_detect(errors, "email") ~ "Incorrect",
        is.na(email) ~ "Missing",
        TRUE ~ NA_character_)) |> 
  dplyr::select(-c("email", "errors")) |> 
  dplyr::filter(Category != "Good") |> 
  dplyr::group_by(dl_state) |> 
  dplyr::mutate(total_rows = dplyr::n()) |> 
  dplyr::ungroup() |> 
  dplyr::group_by(dl_state, Category) |> 
  dplyr::mutate(proportion = dplyr::n()/nrow(final_data)) |> 
  dplyr::ungroup() |> 
  dplyr::distinct() |> 
  dplyr::group_by(dl_state) |> 
  dplyr::mutate(label = ifelse(row_number() == 1, total_rows, NA)) |> 
  dplyr::ungroup() |> 
  # Plot
  ggplot2::ggplot() +
  ggplot2::geom_bar(
    ggplot2::aes(
      y = proportion,
      x = reorder(dl_state, total_rows),
      fill = Category),
    stat = "identity") +
  ggplot2::geom_text(
    ggplot2::aes(
      y = proportion,
      x = reorder(dl_state, total_rows),
      label = label,
      angle = 90),
    vjust = 0.2, hjust = -0.2) +
  ggplot2::labs(
    x = "State",
    y = "Emails (proportion)",
    title = "Erroneous emails by state") +
  ggplot2::scale_y_continuous(
    expand = ggplot2::expansion(mult = c(-0, 0.3))) +
  ggplot2::theme_classic() +
  ggplot2::theme(
    axis.text.x = 
      ggplot2::element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggplot2::scale_fill_manual(
    "Category", 
    labels = c("Incorrect", "Missing"), 
    values = c("#F8766D", "grey35"))

```


## Duplicates

### Before fixDuplicates (all 49 states)

```{r b_fd}
#| fig.align: center
#| echo: false

findDuplicates(current_data)

rm(current_data)
```

### After fixDuplicates (all 49 states)

```{r a_fd}
#| echo: false
#| fig.align: center

findDuplicates(fixed_data)

DT::datatable(findDuplicates(fixed_data, return = "table"))

rm(fixed_data)
```

## Strata

```{r stratacheck}
#| echo: false

DT::datatable(
  strataCheck(final_data),
  extensions = "Buttons",
  options = 
    list(
      dom = "Bfrtip",
      buttons = c("csv", "excel", "pdf"))
  )
```

## Repeated values

### Horizontally repeated values across duck, goose, and snipe_coot bag fields

The table below shows how many records had horizontal repetition across the duck, goose, and snipe_coot columns. For each source file, the value repeated is indicated (h_value), the number of records with horizontal repetition in the file are reported (h_rep), the total number of records per file are reported (h_total), and the proportion of the file with horizontal repetition is indicated (prop_repeat).

```{r h_validateA1}
#| echo: false

h_valid <- migbirdHIP::validate(final_data, type = "horizontal")

DT::datatable(
  h_valid |> 
    dplyr::mutate(prop_repeat = round(prop_repeat, digits = 2)))
```

#### Summary table

```{r h_validateA2}
#| echo: false

if(nrow(h_valid) == 0){
  message("No horizontal repetition to summarize.")
}else{
  kableExtra::kbl(
    h_valid |> 
      dplyr::filter(prop_repeat > 0.001) |> 
      dplyr::mutate(
        dl_state = 
          stringr::str_extract(source_file, "^[A-Z]{2}"),
        binned_proportion = 
          paste0(
            as.numeric(
              stringr::str_extract(
                as.character(prop_repeat), "(?<=0\\.)[0-9]{1}"))*10, "%")
      ) |> 
      dplyr::group_by(binned_proportion) |> 
      dplyr::summarize(States = paste(dl_state, collapse = ", ")) |> 
      dplyr::filter(binned_proportion != "0%") |> 
      dplyr::arrange(dplyr::desc(binned_proportion)) |> 
      dplyr::rename(`Binned proportion` = binned_proportion)) |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = F)
}
```

### Horizontally repeated values across all bag fields

```{r h_validateB1}
#| echo: false

all_h_valid <- validate(final_data, type = "horizontal", all = T)

DT::datatable(
  all_h_valid |> 
    dplyr::mutate(prop_repeat = round(prop_repeat, digits = 2)))
```

#### Summary table

```{r h_validateB2}
#| echo: false

if(nrow(h_valid) == 0){
  message("No horizontal repetition to summarize.")
}else{
  kableExtra::kbl(
    all_h_valid |> 
      dplyr::filter(prop_repeat > 0.001) |> 
      dplyr::mutate(
        dl_state = 
          stringr::str_extract(source_file, "^[A-Z]{2}"),
        binned_proportion = 
          paste0(
            as.numeric(
              stringr::str_extract(
                as.character(prop_repeat), "(?<=0\\.)[0-9]{1}"))*10, "%")
      ) |> 
      dplyr::group_by(binned_proportion) |> 
      dplyr::summarize(States = paste(dl_state, collapse = ", ")) |> 
      dplyr::filter(binned_proportion != "0%") |> 
      dplyr::arrange(dplyr::desc(binned_proportion)) |> 
      dplyr::rename(`Binned proportion` = binned_proportion)) |>
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = F)
}
```

### Vertically repeated values within ducks_bag

The table below shows how many records per file had the same value for all rows of the ducks_bag column. The v_repeated field indicates total count.

```{r v_validate}
#| echo: false

DT::datatable(migbirdHIP::validate(final_data, type = "vertical"))
```

# Error Visualizations

## By field

### Before correction

```{r erpf}
#| echo: false
#| fig.align: center

errorPlot_fields(proofed_data, year = params$year, youth = T)
```

### After correction

```{r erpf_c}
#| echo: false
#| fig.align: center
#| warning: false

# Get the order of the fields so that they match the plot above
x_order <-
  proofed_data |>
  dplyr::select(errors) |>
  # Pull errors apart, delimited by hyphens
  tidyr::separate(errors, into = as.character(c(1:25)), sep = "-") |>
  # Transform errors into a single column
  tidyr::pivot_longer(1:25, names_to = "name") |>
  dplyr::select(errors = value) |>
  dplyr::filter(!is.na(errors)) |>
  dplyr::group_by(errors) |>
  # Count number of correct values
  dplyr::summarize(count_errors = sum(!is.na(errors))) |>
  dplyr::ungroup() |>
  # Calculate error proportion
  dplyr::mutate(
    total = nrow(proofed_data),
    proportion = count_errors / nrow(proofed_data)) |>
  dplyr::arrange(proportion) |> 
  dplyr::select(errors) |> 
  dplyr::mutate(order = dplyr::row_number())

table_1 <-
  final_data |>
  dplyr::mutate(
    birth_year = 
      stringr::str_extract(birth_date, "(?<=\\/)[0-9]{4}$"),
    special =
      ifelse(
        birth_year > params$year - 16,
        "Youth Hunter",
        NA)) |>
  dplyr::select(errors, special) |>
  # Pull errors apart, delimited by hyphens
  tidyr::separate(errors, into = as.character(c(1:25)), sep = "-") |>
  # Transform errors into a single column
  tidyr::pivot_longer(1:25, names_to = "name") |>
  dplyr::select(errors = value, special) |>
  dplyr::filter(!is.na(errors))

# Step 2: table of errors with proportions calculated -- the youth
# errors must be row bound in
table_2 <-
  table_1 |>
  dplyr::group_by(errors) |>
  # Count number of correct and incorrect values
  dplyr::summarize(count_errors = sum(!is.na(errors))) |>
  dplyr::ungroup() |>
  dplyr::filter(errors != "birth_date") |>
  dplyr::bind_rows(
    table_1 |>
      dplyr::group_by(errors, special) |>
      dplyr::summarize(count_errors = sum(!is.na(errors))) |>
      dplyr::ungroup() |>
      dplyr::filter(errors == "birth_date")) |>
  # Calculate error proportion
  dplyr::mutate(
    total = nrow(final_data),
    proportion = count_errors / nrow(final_data))

# Labels for bar plot (birth_date color stack doesn't cooperate with
# positioning 2 labels, so we only label that field once at the top of
# the bar)
barlabels <-
  table_2 |>
  dplyr::select(-c("special", "total")) |>
  dplyr::group_by(errors) |>
  dplyr::mutate(
    count_errors = sum(count_errors),
    proportion = sum(proportion)) |>
  dplyr::ungroup()

# Plot
x_order |>
  dplyr::left_join(table_2, by = "errors") |> 
  dplyr::mutate(
    proportion = ifelse(is.na(proportion), 0, proportion),
    total = ifelse(is.na(total), 0, total)) |>
  dplyr::group_by(errors) |> 
  dplyr::mutate(
    count_errors = sum(count_errors),
    cumulative_prop = sum(proportion)) |> 
  dplyr::ungroup() |> 
  ggplot2::ggplot() +
  ggplot2::geom_bar(
    ggplot2::aes(
      x = stats::reorder(errors, order), 
      y = proportion, 
      fill = special),
    stat = "identity") +
  ggplot2::geom_text(
    ggplot2::aes(x = errors,
        y = cumulative_prop,
        label = count_errors,
        angle = 90),
    vjust = 0.2, hjust = -0.2) +
  ggplot2::labs(
    x = "Field",
    y = "Error proportion",
    title = "Error proportion per field",
    fill = "Specifics") +
  ggplot2::scale_y_continuous(
    expand = ggplot2::expansion(mult = c(-0, 0.25))) +
  ggplot2::theme_classic() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggplot2::scale_fill_discrete(labels = "Youth Hunter", breaks = "Youth Hunter")

rm(x_order) 
rm(table_1)
rm(table_2)
rm(barlabels)

```

## By state

### Before correction

```{r erps}
#| echo: false
#| fig.align: center

errorPlot_states(proofed_data)
```

### After correction

```{r erps_c}
#| echo: false
#| fig.align: center

errorPlot_states(final_data)

rm(final_data)
```

# Error Exploration

The tables below show a closer look at errors and issues within this download's HIP data. Note that some of these values may have been corrected; what is being displayed are the errors that were caught.

## High error counts

Q: What were the most common fields with errors, and what values caused them?

Most common error fields...

```{r et}
#| echo: false

et <- errorTable(proofed_data, loc = "none") |> dplyr::arrange(dplyr::desc(error_count))

DT::datatable(et)
```

Values associated with error in `r et$error[1]`

```{r pe_1}
#| echo: false

if(et$error[1] != "birth_date"){
  err1 <- 
    pullErrors(proofed_data, error = et$error[1], distinct = FALSE) |> 
    tibble::as_tibble() |> 
    dplyr::mutate(
      value = stringi::stri_enc_toutf8(value, is_unknown_8bit = T, validate = T)) |>
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
  }else{
  err1 <- 
    pullErrors(proofed_data, error = et$error[1], distinct = FALSE) |> 
    tibble::as_tibble() |> 
    dplyr::mutate(value = stringr::str_extract(value, ".{4}$")) |> 
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
}

DT::datatable(err1)
```

Values associated with error in `r et$error[2]`

```{r pe_2}
#| echo: false

if(et$error[2] != "birth_date"){
  err2 <- 
    pullErrors(proofed_data, error = et$error[2], distinct = FALSE) |> 
    tibble::as_tibble() |> 
    dplyr::mutate(
      value = 
        stringi::stri_enc_toutf8(value, is_unknown_8bit = T, validate = T)) |>
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
  }else{
  err2 <- 
    pullErrors(proofed_data, error = et$error[2], distinct = FALSE) |> 
    tibble::as_tibble() |> 
    dplyr::mutate(value = stringr::str_extract(value, ".{4}$")) |> 
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
}

DT::datatable(err2)
```

Values associated with error in `r et$error[3]`

```{r pe_3}
#| echo: false

if(et$error[3] != "birth_date"){
  err3 <- 
    pullErrors(proofed_data, error = et$error[3], distinct = FALSE) |> 
    tibble::as_tibble() |> 
    dplyr::mutate(
      value = 
        stringi::stri_enc_toutf8(value, is_unknown_8bit = T, validate = T)) |>
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
  }else{
  err3 <- 
    pullErrors(proofed_data, error = et$error[3], distinct = FALSE) |> 
    tibble::as_tibble() |>  
    dplyr::mutate(value = stringr::str_extract(value, ".{4}$")) |> 
    dplyr::group_by(value) |> 
    dplyr::summarize(count = dplyr::n()) |> 
    dplyr::ungroup() |> 
    dplyr::arrange(dplyr::desc(count))
}

DT::datatable(err3)
```

## High error proportions

Q: What states and fields had a proportion of error that exceeded an acceptable threshold (before correction)?

States with more than 1% error

```{r rfs}
#| echo: false

redFlags(proofed_data, type = "state", threshold = 0.01)
```

Fields with more than 1% error

```{r rff}
#| echo: false

redFlags(proofed_data, type = "field", threshold = 0.01)
```
